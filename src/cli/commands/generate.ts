import { promises as fs } from 'fs'
import * as path from 'path'
import chalk from 'chalk'
import { NOORMME } from '../../noormme.js'
import { TableInfo, ColumnInfo } from '../../types/index.js'
import { sanitizeDatabasePath, validateOutputDirectory } from '../../util/security-validator.js'

export async function generate(options: {
  database?: string
  output?: string
  typesOnly?: boolean
  reposOnly?: boolean
  format?: string
} = {}) {
  console.log(chalk.blue.bold('\nðŸ”§ NOORMME Code Generation - Automating TypeScript & Repositories\n'))

  try {
    // SECURITY: Validate and sanitize database path to prevent path traversal attacks
    const databasePathInput = options.database || process.env.DATABASE_PATH || './database.sqlite'
    const databasePath = sanitizeDatabasePath(databasePathInput)

    const db = new NOORMME({
      dialect: 'sqlite',
      connection: {
        database: databasePath,
        host: 'localhost',
        port: 0,
        username: '',
        password: ''
      }
    })
    await db.initialize()

    const schemaInfo = await db.getSchemaInfo()

    // SECURITY: Validate output directory to prevent path traversal attacks
    const outputDir = options.output || './generated'
    validateOutputDirectory(outputDir)

    const format = options.format || 'dts'

    console.log(chalk.gray(`ðŸ“ Output directory: ${outputDir}`))
    console.log(chalk.gray(`ðŸ“Š Discovered ${schemaInfo.tables.length} tables\n`))

    // Ensure output directory exists
    await fs.mkdir(outputDir, { recursive: true })

    let generatedFiles: string[] = []

    // Generate TypeScript types if not repos-only
    if (!options.reposOnly) {
      const typesContent = generateTypeScriptTypes(schemaInfo.tables)
      const typesFile = format === 'dts' ? 'database.d.ts' : 'database.ts'
      const typesPath = path.join(outputDir, typesFile)
      
      await fs.writeFile(typesPath, typesContent)
      generatedFiles.push(typesPath)
      console.log(chalk.green(`âœ… Generated TypeScript types: ${typesFile}`))
    }

    // Generate repository classes if not types-only
    if (!options.typesOnly) {
      const reposContent = generateRepositoryClasses(schemaInfo.tables)
      const reposPath = path.join(outputDir, 'repositories.ts')
      
      await fs.writeFile(reposPath, reposContent)
      generatedFiles.push(reposPath)
      console.log(chalk.green(`âœ… Generated repository classes: repositories.ts`))
    }

    // Generate automation configuration
    const configContent = generateAutomationConfig(schemaInfo.tables)
    const configPath = path.join(outputDir, 'automation.config.ts')
    
    await fs.writeFile(configPath, configContent)
    generatedFiles.push(configPath)
    console.log(chalk.green(`âœ… Generated automation config: automation.config.ts`))

    // Generate usage examples
    const examplesContent = generateUsageExamples(schemaInfo.tables)
    const examplesPath = path.join(outputDir, 'usage-examples.ts')
    
    await fs.writeFile(examplesPath, examplesContent)
    generatedFiles.push(examplesPath)
    console.log(chalk.green(`âœ… Generated usage examples: usage-examples.ts`))

    console.log(chalk.green.bold(`\nðŸŽ‰ Generated ${generatedFiles.length} files successfully!`))
    console.log(chalk.blue('\nNext steps:'))
    console.log(chalk.gray('1. Import and use the generated types in your project'))
    console.log(chalk.gray('2. Use the repository classes for type-safe database operations'))
    console.log(chalk.gray('3. Configure automation settings in automation.config.ts'))
    console.log(chalk.gray('4. Check usage-examples.ts for implementation patterns'))

    await db.close()

  } catch (error) {
    console.error(chalk.red('âŒ Code generation failed:'), error instanceof Error ? error.message : error)
    process.exit(1)
  }
}

function generateTypeScriptTypes(tables: TableInfo[]): string {
  const interfaces = tables.map(table => generateTableInterface(table)).join('\n\n')

  const databaseInterface = `export interface Database {
${tables.map(t => `  ${t.name}: ${pascalCase(t.name)}Table;`).join('\n')}
}`

  return `// Auto-generated by NOORMME CLI
// Do not edit manually - regenerate with: npx noormme generate

${interfaces}

${databaseInterface}

// Repository types for each table
${tables.map(table => generateRepositoryType(table)).join('\n\n')}

// Export all table types
export type {
${tables.map(t => `  ${pascalCase(t.name)}Table,`).join('\n')}
${tables.map(t => `  ${pascalCase(t.name)}Insert,`).join('\n')}
${tables.map(t => `  ${pascalCase(t.name)}Update,`).join('\n')}
${tables.map(t => `  ${pascalCase(t.name)}Repository,`).join('\n')}
}
`
}

function generateTableInterface(table: TableInfo): string {
  const tableName = pascalCase(table.name)

  // Base table interface
  const baseInterface = `export interface ${tableName}Table {
${table.columns.map(col => generateColumnType(col)).join('\n')}
}`

  // Insert type (optional fields that have defaults or are auto-increment)
  const requiredFields = table.columns.filter(col =>
    !col.nullable &&
    !col.isAutoIncrement &&
    col.defaultValue === undefined &&
    !col.isPrimaryKey
  )
  const optionalFields = table.columns.filter(col =>
    col.nullable ||
    col.isAutoIncrement ||
    col.defaultValue !== undefined
  )

  const insertInterface = `export interface ${tableName}Insert {
${requiredFields.map(col => generateColumnType(col)).join('\n')}
${optionalFields.map(col => generateColumnType(col, true)).join('\n')}
}`

  // Update type (all fields optional except primary key)
  const updateInterface = `export interface ${tableName}Update {
${table.columns.map(col => generateColumnType(col, !col.isPrimaryKey)).join('\n')}
}`

  return `${baseInterface}

${insertInterface}

${updateInterface}`
}

function generateRepositoryType(table: TableInfo): string {
  const tableName = pascalCase(table.name)
  const primaryKeyType = getPrimaryKeyType(table)

  return `export interface ${tableName}Repository {
  findById(id: ${primaryKeyType}): Promise<${tableName}Table | null>;
  findAll(): Promise<${tableName}Table[]>;
  create(data: ${tableName}Insert): Promise<${tableName}Table>;
  update(entity: ${tableName}Update): Promise<${tableName}Table>;
  delete(id: ${primaryKeyType}): Promise<boolean>;
  count(): Promise<number>;
  exists(id: ${primaryKeyType}): Promise<boolean>;
  paginate(options: {
    page: number;
    limit: number;
    where?: Partial<${tableName}Table>;
    orderBy?: {
      column: keyof ${tableName}Table;
      direction: 'asc' | 'desc';
    };
  }): Promise<{
    data: ${tableName}Table[];
    pagination: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
      hasNext: boolean;
      hasPrev: boolean;
    };
  }>;
  withCount(id: ${primaryKeyType}, relationships: string[]): Promise<${tableName}Table & Record<string, number>>;
  // Dynamic finders
${table.columns.map(col => `  findBy${pascalCase(col.name)}(value: ${mapColumnToTsType(col)}): Promise<${tableName}Table | null>;`).join('\n')}
${table.columns.map(col => `  findManyBy${pascalCase(col.name)}(value: ${mapColumnToTsType(col)}): Promise<${tableName}Table[]>;`).join('\n')}
}`
}

function generateColumnType(column: ColumnInfo, optional = false): string {
  const name = column.name
  const type = mapColumnToTsType(column)
  const nullableType = column.nullable ? ` | null` : ''
  const optionalMark = optional ? '?' : ''

  return `  ${name}${optionalMark}: ${type}${nullableType};`
}

function mapColumnToTsType(column: ColumnInfo): string {
  const type = column.type.toLowerCase()

  // Integer types
  if (type.includes('int') || type.includes('serial') || type.includes('bigint')) {
    return 'number'
  }

  // Float types
  if (type.includes('float') || type.includes('double') || type.includes('decimal') || type.includes('numeric')) {
    return 'number'
  }

  // Boolean types
  if (type.includes('bool')) {
    return 'boolean'
  }

  // Date/time types
  if (type.includes('date') || type.includes('time') || type.includes('timestamp')) {
    return 'Date'
  }

  // JSON types
  if (type.includes('json')) {
    return 'Record<string, unknown>'
  }

  // Array types
  if (type.includes('array') || type.includes('[]')) {
    return 'unknown[]'
  }

  // UUID types
  if (type.includes('uuid')) {
    return 'string'
  }

  // Default to string for text types and unknowns
  return 'string'
}

function getPrimaryKeyType(table: TableInfo): string {
  if (!table.primaryKey || table.primaryKey.length === 0) {
    return 'unknown'
  }

  if (table.primaryKey.length === 1) {
    const pkColumn = table.columns.find(col => col.name === table.primaryKey![0])
    return pkColumn ? mapColumnToTsType(pkColumn) : 'unknown'
  }

  // Composite primary key
  const types = table.primaryKey.map(pkCol => {
    const column = table.columns.find(col => col.name === pkCol)
    return column ? mapColumnToTsType(column) : 'any'
  })

  return `[${types.join(', ')}]`
}

function generateRepositoryClasses(tables: TableInfo[]): string {
  const imports = `import { NOORMME } from 'noormme'
import type { 
${tables.map(t => `  ${pascalCase(t.name)}Table,`).join('\n')}
${tables.map(t => `  ${pascalCase(t.name)}Insert,`).join('\n')}
${tables.map(t => `  ${pascalCase(t.name)}Update,`).join('\n')}
} from './database'`

  const repositoryClasses = tables.map(table => {
    const tableName = table.name
    const className = pascalCase(table.name) + 'Repository'
    const primaryKeyType = getPrimaryKeyType(table)

    return `export class ${className} {
  constructor(private db: NOORMME) {}

  async findById(id: ${primaryKeyType}): Promise<${pascalCase(tableName)}Table | null> {
    const repo = this.db.getRepository('${tableName}')
    return await repo.findById(id)
  }

  async findAll(): Promise<${pascalCase(tableName)}Table[]> {
    const repo = this.db.getRepository('${tableName}')
    return await repo.findAll()
  }

  async create(data: ${pascalCase(tableName)}Insert): Promise<${pascalCase(tableName)}Table> {
    const repo = this.db.getRepository('${tableName}')
    return await repo.create(data)
  }

  async update(id: ${primaryKeyType}, data: ${pascalCase(tableName)}Update): Promise<${pascalCase(tableName)}Table> {
    const repo = this.db.getRepository('${tableName}')
    return await repo.update({ ...data, [getPrimaryKeyColumn(table)]: id })
  }

  async delete(id: ${primaryKeyType}): Promise<boolean> {
    const repo = this.db.getRepository('${tableName}')
    return await repo.delete(id)
  }

  async count(): Promise<number> {
    const repo = this.db.getRepository('${tableName}')
    return await repo.count()
  }

  async exists(id: ${primaryKeyType}): Promise<boolean> {
    const repo = this.db.getRepository('${tableName}')
    return await repo.exists(id)
  }

  // Dynamic finders
${table.columns.map(col => `  async findBy${pascalCase(col.name)}(value: ${mapColumnToTsType(col)}): Promise<${pascalCase(tableName)}Table | null> {
    const repo = this.db.getRepository('${tableName}')
    return await repo.findBy${pascalCase(col.name)}(value)
  }`).join('\n')}

${table.columns.map(col => `  async findManyBy${pascalCase(col.name)}(value: ${mapColumnToTsType(col)}): Promise<${pascalCase(tableName)}Table[]> {
    const repo = this.db.getRepository('${tableName}')
    return await repo.findManyBy${pascalCase(col.name)}(value)
  }`).join('\n')}
}`
  }).join('\n\n')

  const factoryClass = `export class RepositoryFactory {
  constructor(private db: NOORMME) {}

${tables.map(table => `  get ${table.name}(): ${pascalCase(table.name)}Repository {
    return new ${pascalCase(table.name)}Repository(this.db)
  }`).join('\n')}
}`

  return `${imports}

${repositoryClasses}

${factoryClass}

// Convenience function to create repository factory
export function createRepositoryFactory(db: NOORMME): RepositoryFactory {
  return new RepositoryFactory(db)
}
`
}

function generateAutomationConfig(tables: TableInfo[]): string {
  return `// NOORMME Automation Configuration
// This file contains recommended automation settings for your database

import type { NOORMConfig } from 'noormme'

export const automationConfig: Partial<NOORMConfig> = {
  dialect: 'sqlite',
  
  // Performance optimizations
  performance: {
    enableAutoOptimization: true,
    enableQueryOptimization: true,
    enableCaching: true,
    enableBatchOperations: true,
    maxCacheSize: 1000
  },

  // SQLite-specific optimizations
  sqlite: {
    enableWALMode: true,
    enableForeignKeys: true,
    cacheSize: -64000, // 64MB
    synchronous: 'NORMAL',
    tempStore: 'MEMORY',
    autoVacuumMode: 'INCREMENTAL'
  },

  // Schema discovery settings
  introspection: {
    excludeTables: ['migrations', 'temp_*'],
    includeViews: true,
    customTypeMappings: {
      // Add custom type mappings here
    }
  },

  // Logging configuration
  logging: {
    enabled: true,
    level: 'info',
    includeQueryTime: true,
    includeQueryResults: false
  },

  // Cache configuration
  cache: {
    ttl: 300000, // 5 minutes
    maxSize: 1000,
    enableCompression: true
  }
}

// Table-specific automation settings
export const tableAutomationSettings = {
${tables.map(table => `  ${table.name}: {
    // Auto-generated settings for ${table.name} table
    enableAutoIndexing: true,
    enablePerformanceMonitoring: true,
    recommendedIndexes: [
      ${table.columns.filter(col => col.name.includes('email') || col.name.includes('status') || col.name.includes('created')).map(col => `'${col.name}'`).join(',\n      ') || '// No recommended indexes'}
    ]
  },`).join('\n')}
}

// Usage example:
// import { NOORMME } from 'noormme'
// import { automationConfig } from './automation.config'
// 
// const db = new NOORMME(automationConfig)
// await db.initialize()
`
}

function generateUsageExamples(tables: TableInfo[]): string {
  const firstTable = tables[0]
  const tableName = firstTable?.name || 'users'
  const className = pascalCase(tableName) + 'Repository'

  return `// NOORMME Usage Examples
// This file shows how to use the generated types and repositories

import { NOORMME } from 'noormme'
import { createRepositoryFactory } from './repositories'
import { automationConfig } from './automation.config'

// Initialize NOORMME with automation
const db = new NOORMME(automationConfig)
await db.initialize()

// Create repository factory
const repositories = createRepositoryFactory(db)

// Example 1: Basic CRUD operations
async function basicCrudExample() {
  const ${tableName}Repo = repositories.${tableName}
  
  // Create a new record
  const new${pascalCase(tableName)} = await ${tableName}Repo.create({
    ${firstTable?.columns.filter(col => !col.isAutoIncrement && !col.isPrimaryKey).slice(0, 3).map(col => `${col.name}: 'example_value'`).join(',\n    ') || '// Add your data here'}
  })
  
  // Find by ID
  const ${tableName} = await ${tableName}Repo.findById(new${pascalCase(tableName)}.id)
  
  // Update record
  const updated${pascalCase(tableName)} = await ${tableName}Repo.update(new${pascalCase(tableName)}.id, {
    // Add fields to update
  })
  
  // Delete record
  await ${tableName}Repo.delete(new${pascalCase(tableName)}.id)
}

// Example 2: Using dynamic finders
async function dynamicFinderExample() {
  const ${tableName}Repo = repositories.${tableName}
  
  ${firstTable?.columns.filter(col => !col.isPrimaryKey).slice(0, 2).map(col => `
  // Find by ${col.name}
  const ${tableName}By${pascalCase(col.name)} = await ${tableName}Repo.findBy${pascalCase(col.name)}('value')
  
  // Find many by ${col.name}
  const ${tableName}sBy${pascalCase(col.name)} = await ${tableName}Repo.findManyBy${pascalCase(col.name)}('value')`).join('') || '// Dynamic finders will be available based on your table columns'}
}

// Example 3: Direct repository access
async function directRepositoryExample() {
  // Get repository directly from NOORMME
  const ${tableName}Repo = db.getRepository('${tableName}')
  
  // Use all repository methods
  const all${pascalCase(tableName)}s = await ${tableName}Repo.findAll()
  const count = await ${tableName}Repo.count()
  const exists = await ${tableName}Repo.exists(1)
}

// Example 4: Complex queries with Kysely
async function complexQueryExample() {
  const kysely = db.getKysely()
  
  // Type-safe complex queries
  const result = await kysely
    .selectFrom('${tableName}')
    .selectAll()
    .where('status', '=', 'active')
    .orderBy('created_at', 'desc')
    .limit(10)
    .execute()
}

// Example 5: Performance monitoring
async function performanceExample() {
  // Get performance metrics
  const metrics = await db.getSQLitePerformanceMetrics()
  console.log('Cache hit rate:', metrics.cacheHitRate)
  console.log('Average query time:', metrics.averageQueryTime)
  
  // Get optimization recommendations
  const recommendations = await db.getSQLiteIndexRecommendations()
  console.log('Recommended indexes:', recommendations.recommendations)
}

// Example 6: Migration management
async function migrationExample() {
  const migrationManager = db.getMigrationManager()
  
  // Initialize migration manager
  await migrationManager.initialize()
  
  // Generate a new migration
  await migrationManager.generateMigration('add_new_column')
  
  // Apply migrations
  await migrationManager.executeMigrations()
  
  // Check migration status
  const status = await migrationManager.getStatus()
  console.log('Migration status:', status)
}

// Run examples
async function runExamples() {
  try {
    console.log('ðŸš€ Running NOORMME examples...')
    
    await basicCrudExample()
    console.log('âœ… Basic CRUD example completed')
    
    await dynamicFinderExample()
    console.log('âœ… Dynamic finder example completed')
    
    await directRepositoryExample()
    console.log('âœ… Direct repository example completed')
    
    await complexQueryExample()
    console.log('âœ… Complex query example completed')
    
    await performanceExample()
    console.log('âœ… Performance example completed')
    
    console.log('ðŸŽ‰ All examples completed successfully!')
    
  } catch (error) {
    console.error('âŒ Example failed:', error)
  } finally {
    await db.close()
  }
}

// Uncomment to run examples
// runExamples()
`
}

function getPrimaryKeyColumn(table: TableInfo): string {
  return table.primaryKey?.[0] || 'id'
}

function pascalCase(str: string): string {
  return str
    .replace(/(?:^\w|[A-Z]|\b\w)/g, (word) => word.toUpperCase())
    .replace(/\s+/g, '')
    .replace(/[_-]/g, '')
}